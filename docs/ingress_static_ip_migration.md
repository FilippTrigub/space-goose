# Shared Ingress Migration Notes

## Background
- Each project currently provisions a distinct `LoadBalancer` Service, which causes slow or failed public-IP assignments when pods churn.
- Move to a single ingress layer with a reserved static IP so pods only need `ClusterIP` Services and HTTP routing is managed centrally.

## Cluster Changes (Commands)
- Reserve a Standard SKU static public IP and (optionally) an Azure-provided DNS label. Replace the placeholders before running these commands in Windows Command Prompt.

```sh
set RESOURCE_GROUP=<aks-node-rg>
set LOCATION=<azure-region>        REM example: eastus
set DNS_LABEL=goose-%RANDOM%       REM set to blank ("set DNS_LABEL=") if you do not want Azure to host DNS

if defined DNS_LABEL (
  az network public-ip create ^
    --resource-group %RESOURCE_GROUP% ^
    --name goose-static-ingress ^
    --sku Standard ^
    --allocation-method static ^
    --dns-name %DNS_LABEL% ^
    --location %LOCATION%
) else (
  az network public-ip create ^
    --resource-group %RESOURCE_GROUP% ^
    --name goose-static-ingress ^
    --sku Standard ^
    --allocation-method static ^
    --location %LOCATION%
)

for /f "delims=" %I in ( ^
  'az network public-ip show --resource-group %RESOURCE_GROUP% --name goose-static-ingress --query "ipAddress" -o tsv' ^
) do set STATIC_INGRESS_IP=%I

if defined DNS_LABEL (
  set PUBLIC_APP_DOMAIN=%DNS_LABEL%.%LOCATION%.cloudapp.azure.com
) else (
  set PUBLIC_APP_DOMAIN=<your-domain.example.com>
)

set INGRESS_CLASS_NAME=nginx

echo Static ingress IP: %STATIC_INGRESS_IP%
echo Public app domain: %PUBLIC_APP_DOMAIN%
```

> **Note:** `PUBLIC_APP_DOMAIN` must always be non-empty for the Python service. If you rely on Azureâ€™s autogenerated host, keep `DNS_LABEL` defined and use the resulting `*.cloudapp.azure.com` value here. Otherwise provide a domain you control and point its DNS records at the static IP.

- Deploy (or update) the ingress controller pinned to the static IP. This mirrors the syntax used in `docs\KUBERNETES_SETUP.md` so it can be pasted directly into Command Prompt.

```sh
if not exist infra mkdir infra

(
echo apiVersion: v1
echo kind: Namespace
echo metadata:
echo ^  name: ingress-nginx
echo ---
echo apiVersion: apps/v1
echo kind: Deployment
echo metadata:
echo ^  name: ingress-nginx-controller
echo ^  namespace: ingress-nginx
echo spec:
echo ^  replicas: 2
echo ^  selector:
echo ^    matchLabels:
echo ^      app.kubernetes.io/name: ingress-nginx
echo ^      app.kubernetes.io/component: controller
echo ^  template:
echo ^    metadata:
echo ^      labels:
echo ^        app.kubernetes.io/name: ingress-nginx
echo ^        app.kubernetes.io/component: controller
echo ^    spec:
echo ^      serviceAccountName: ingress-nginx
echo ^      containers:
echo ^      - name: controller
echo ^        image: registry.k8s.io/ingress-nginx/controller:v1.11.1
echo ^        args:
echo ^        - /nginx-ingress-controller
echo ^        - --publish-service=$(POD_NAMESPACE)/ingress-nginx-controller
echo ^        - --ingress-class=nginx
echo ^        readinessProbe:
echo ^          httpGet:
echo ^            path: /healthz
echo ^            port: 10254
echo ^        livenessProbe:
echo ^          httpGet:
echo ^            path: /healthz
echo ^            port: 10254
echo ---
echo apiVersion: v1
echo kind: Service
echo metadata:
echo ^  name: ingress-nginx-controller
echo ^  namespace: ingress-nginx
echo ^  annotations:
echo ^    service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path: /healthz
echo spec:
echo ^  type: LoadBalancer
echo ^  loadBalancerIP: %STATIC_INGRESS_IP%
echo ^  externalTrafficPolicy: Local
echo ^  ports:
echo ^  - name: http
echo ^    port: 80
echo ^    targetPort: 80
echo ^  - name: https
echo ^    port: 443
echo ^    targetPort: 443
echo ^  selector:
echo ^    app.kubernetes.io/name: ingress-nginx
echo ^    app.kubernetes.io/component: controller
) > infra\ingress-nginx.yaml

kubectl apply -f infra\ingress-nginx.yaml
```

- For each project namespace, generate the ClusterIP Service and the Ingress. Set the variables first so the host is built consistently with the Python logic.

```sh
set USER_ID=<user-id>
set PROJECT_ID=<project-id>
set PROJECT_HOST=%PROJECT_ID%-%USER_ID%.%PUBLIC_APP_DOMAIN%

if not exist environments mkdir environments
if not exist environments\user-%USER_ID% mkdir environments\user-%USER_ID%
if not exist environments\user-%USER_ID%\proj-%PROJECT_ID% mkdir environments\user-%USER_ID%\proj-%PROJECT_ID%

(
echo apiVersion: v1
echo kind: Service
echo metadata:
echo ^  name: proj-%PROJECT_ID%-api
echo ^  namespace: user-%USER_ID%
echo ^  labels:
echo ^    app: proj-%PROJECT_ID%-api
echo ^    project-id: %PROJECT_ID%
echo ^    user-id: %USER_ID%
echo spec:
echo ^  selector:
echo ^    app: proj-%PROJECT_ID%-api
echo ^  ports:
echo ^  - name: http
echo ^    port: 80
echo ^    targetPort: 3001
echo ^  type: ClusterIP
) > environments\user-%USER_ID%\proj-%PROJECT_ID%\service.yaml

(
echo apiVersion: networking.k8s.io/v1
echo kind: Ingress
echo metadata:
echo ^  name: proj-%PROJECT_ID%-api
echo ^  namespace: user-%USER_ID%
echo ^  annotations:
echo ^    kubernetes.io/ingress.class: %INGRESS_CLASS_NAME%
echo spec:
echo ^  rules:
echo ^  - host: %PROJECT_HOST%
echo ^    http:
echo ^      paths:
echo ^      - path: /
echo ^        pathType: Prefix
echo ^        backend:
echo ^          service:
echo ^            name: proj-%PROJECT_ID%-api
echo ^            port:
echo ^              number: 80
) > environments\user-%USER_ID%\proj-%PROJECT_ID%\ingress.yaml

REM Append a TLS section manually if you manage certificates for %PROJECT_HOST%

kubectl apply -f environments\user-%USER_ID%\proj-%PROJECT_ID%\service.yaml
kubectl apply -f environments\user-%USER_ID%\proj-%PROJECT_ID%\ingress.yaml
```

## Python Service Orchestration Updates (`k8s_manager/services/k8s_service.py`)
- `apply_project_resources`:
  - Change the generated Service to `type="ClusterIP"` and remove per-port Azure load-balancer annotations.
  - After creating the Service, create or patch a matching Ingress resource using the host pattern above; ensure host/domain comes from configuration (e.g., `PUBLIC_APP_DOMAIN`).
  - Inject TLS secret name only when certificate automation is enabled; otherwise skip the TLS block.
- `wait_for_loadbalancer_ip`:
  - Replace with `wait_for_ingress_ready` that polls `NetworkingV1Api.read_namespaced_ingress` until `.status.loadBalancer.ingress[0].ip|hostname` is set.
  - Reuse the shared static IP check only once (ingress should immediately point to the controller IP).
- `get_project_endpoint`:
  - Return the fully qualified host instead of a raw IP; optionally include `https://` scheme when TLS is provisioned.
- `delete_project_resources`:
  - Add deletion of the `Ingress` object prior to Service removal to avoid stale hosts.
- Configuration:
  - Introduce a required env var for the public domain suffix and optionally one for the ingress class name.
  - Update logs/error messages to reference ingress readiness rather than load balancer provisioning.

## Follow-Up
- Run smoke tests (external curl) against the new ingress endpoint after deployment.
- Update any DNS automation to create host records that map to the static IP before first traffic hits the ingress controller.
- Set the environment variables (`PUBLIC_APP_DOMAIN`, `INGRESS_CLASS_NAME`, optional `INGRESS_TLS_SECRET_PATTERN`) everywhere the Python service runs; re-source them before restarting `k8s_manager`.
- Re-run the `envsubst ... | kubectl apply -f -` commands whenever you change controller images, static IPs, or namespace defaults.
